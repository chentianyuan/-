// 486. 预测赢家
// 给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

// 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

// 示例 1：
// 输入：[1, 5, 2]
// 输出：False
// 解释：一开始，玩家1可以从1和2中进行选择。
// 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
// 所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
// 因此，玩家 1 永远不会成为赢家，返回 False 。

// 示例 2：
// 输入：[1, 5, 233, 7]
// 输出：True
// 解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
// 最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var PredictTheWinner = function(nums) {
  if (nums.length % 2 === 0) return true
  let len = nums.length
  let dp = new Array()
  // 定义dp数组
  for (let i = 0; i < len; i++) {
    dp[i] = []
    for (let j = 0; j < len; j++) {
      dp[i][j] = i === j ? nums[i]: 0
    }
  }

  // dp[i][j]的值用于存储当数组下标为i->j时，先手和后手的差值
  // 因此只有当j>=i时，dp[i][j]才有意义
  // 自底向上，从长度为1的末尾开始，如果i从0开始，[0,len]无法得出正确结果
  for (let i = len - 2; i >= 0; i--) {
    for (let j = i + 1; j < len; j++) {
      dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
    }
  }

  return dp[0][len - 1] >= 0
};

// 解题思路：
// 也可以采用回溯的方法遍历每一种可能，由于存在重复子问题，可以推导出状态转移方程
// dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
// 其实dp也是回溯的一种，不过储存的可能出现的情况，因此时间复杂度要好得多
