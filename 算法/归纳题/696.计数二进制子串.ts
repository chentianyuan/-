// 696. 计数二进制子串
// 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

// 重复出现的子串要计算它们出现的次数。

// 示例 1 :

// 输入: "00110011"
// 输出: 6
// 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

// 请注意，一些重复出现的子串要计算它们出现的次数。

// 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
// 示例 2 :

// 输入: "10101"
// 输出: 4
// 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
function countBinarySubstrings(s: string): number {
  let result = 0
  let counts = []
  for (let key = 0; key < s.length;) {
    let count = 1
    while (key < s.length) {
      key++
      if (s[key] === s[key - 1]) {
        count++
      } else {
        counts.push(count)
        break
      }
    }
  }
  for (let i = 1; i < counts.length; i++) {
    result += Math.min(counts[i], counts[i - 1])
  }
  return result
};

// 解题思路:
// 例如00110011这样的串，按照0，1进行连续的分组，得数组[2,2,2,2]，然后题意中的子串一定是由n个0n个1组成（仅进行一次01变化），因此仅需遍历数组，取相邻数字中较小的那个累加即可